# Tip
## 线性表

1.  取值插入删除时注意位置的合法性
2.  插入时注意``listsize``的溢出
3.  双向链表插入删除的时候有4个指针要操作

## 栈

1.  ``Push()``时注意栈溢出
2.  ``S.top``指向即将push进入的位置

## 队列

1.  循环队列中``Q.rear``指向下一个将入队的位置
2.  两种方式处理循环队列
    1.  设标志判断队空队满
    2.  空一个位置

## 串

定长顺序存储
1.  串连接需要考虑截断
2.  求子串考虑起始位置和长度的合法性

堆分配存储表示
1.  注意要覆盖原串，需要将原串给free

模式匹配

KMP

## 数组

随机存储结构

$LOC(j_1, j_2, ...,j_n)=LOC(0,0,...,0)+L\sum\limits_1^{n}j_nc_n$

$c_n = c_{n-1}b_{n-1}, c_n = 1$

## 矩阵

稀疏矩阵稀疏因子$\delta = \frac{t}{m\times n}, t为非零元，mn为矩阵大小$

稀疏矩阵表示方法

1.  三元组{i, j, e}

三元组的矩阵转置
1.  按顺序查找的方式将在j列的元素放置新表中，然后j += 1
2.  对每列第一个元素的恰当位置进行计算，然后以行序为主序遍历原表，放入相应的位置并更新每一列的恰当位置

2.  行逻辑链接的顺序表，即加入每行第一个非零元的位置表

矩阵相乘MN

M的每行非零元(i,k)乘N的第k行j列元素加至Q的(i, j)位置，全部加完之后压缩存储

时间复杂度$O(M.tu*N.tu/N.mu)$

3.  十字链表right,down,rhead,chead

十字链表的初始化与相加

## 广义表

广义表表长为元素个数，表看成一个整体，一个元素

头尾链表空表为null，拓展线性链表还有一个表节点，只是hp，tp都是null

## 树

### 二叉树

二叉树不是度不大于2的有序树

度不大于2的有序树没有左右孩子之分

$n_0=n_2+1$

n个节点的完全二叉树深度为$[log_2 n]+1$

顺序存储编号i的节点存在i-1的位置

链式存储结构

n个节点有n+1个空链域

先序+中序
,
后序+中序
,
层次+中序
可复原二叉树

存储结构

1.  双亲表示法，结构体包含双亲
2.  孩子表示法，包含孩子链表的头指针
3.  孩子兄弟表示法

### 霍夫曼树

n个叶子的霍夫曼树有2n-1个节点

通过回溯和试探进行图的遍历

含n个节点的不相似的二叉树共$\frac{1}{n+1} C_{2n}^{n}$棵

## 图

### 基本概念

网，带权图

a--->b,a弧尾，b弧头

路径P(a,b)

回路P(a, a)

简单路径即图论中的圈

连通分量即图论中的连通片

一个有向图的生成森林由若干棵有向树组成

### 存储结构

|  存储结构  |                      创建时间复杂度                       |
| :--------: | :-------------------------------------------------------: |
|  邻接矩阵  |                        $O(n^2+en)$                        |
|   邻接表   | $O(n+e)$,若输入为顶点编号；$O(ne)$,若输入为顶点，需要查找 |
|  十字链表  | $O(n+e)$,若输入为顶点编号；$O(ne)$,若输入为顶点，需要查找 |
| 邻接多重表 |                             ?                             |

### 图遍历

DFS用邻接矩阵遍历，查找每个顶点的邻接点所需的总时间是$O(n*n)$

DFS用邻接表遍历，查找邻接点所需时间为$O(e)$，查找顶点需要$O(n)$，总时间$O(n+e)$

### 连通性

#### 最小生成树

Prim

找$(U, \bar{U})$中代价最小的边，让边代价为0，并且将边的另一个端点加入U中，对这个点的邻边更新代价

时间复杂度$O(n^2)$，适合边稠密的图

Kruskal

初始条件是n个孤立顶点

选择两个顶点落在不同连通分量上的代价最小的边

时间复杂度$O(eloge)$，适合边稀疏

#### 关节点和重连通风量

连通度k，至少删去k个顶点才能破坏图的连通性

关节点：
1.  有两棵子树的根
2.  非叶子节点v点的子树中所有节点都没有指向v的祖先的边，v为关节点

$low(v) = min\{visited(v), visited(v->parent, v->parent->parent, ...), low(v->child, v->child->child, ...)\}$

如果$low(v->child) >= visited(v)$，v为割点，如果$count < G.vexnum$，根为割点

### DAG, AOV-N, AOE

DAG:有向无环图

AOV-N:顶点活动网络，表示顶点活动的先后顺序

AOE-N:边活动网络，顶点为事件，表示边活动的开始或者结束

将偏序集变为全序即拓扑排序

拓扑排序可检测AOV-N是否有环，通过不断删去入度为0的顶点和更新其他顶点的入度，如果没有剩余，则没有环，否则有环

时间复杂度$O(e+n+2*n+e)$

