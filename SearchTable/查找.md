##  查找

静态查找表：查询，检索

动态查找表：查询，检索，插入，删除

唯一标识某记录的关键字叫主关键字

平均查找长度ASL：需要和给定关键字进行比较的关键字个数的期望

|     查找方式     |                                                                    ASL                                                                    |
| :--------------: | :---------------------------------------------------------------------------------------------------------------------------------------: |
|     顺序查找     |                                                              $\frac{n+1}{2}$                                                              |
| 折半查找(有序表) |                                                        $\frac{n+1}{n} \log_2 n-1$                                                         |
|    次优查找树    |                                                           构造时间$O(n\log n)$                                                            |
|    索引查找表    | $L_b+L_w，L_b为确定所在块的ASL，L_w为在块中查找的ASL$，顺序查找$\frac{b+1}{2}+\frac{s+1}{2}$，折半查找块$\log(\frac{n}{s}+1)+\frac{s}{2}$ |
二叉排序树|平均性能$\leq2(1+\frac{1}{n}）\ln n$
平衡二叉树|$log n$

斐波那契查找：以斐波那契数列进行分割

插值查找：按照比例查找

次优查找树：取使$\Delta P = |\Sigma_{i左边} w - \Sigma_{i右边} w| = |sw_{h} + sw_{l-1} - sw_i - sw_{i-1}|$最小的i,然后分治

索引顺序表(分块查找)

### 二叉排序树(二叉查找树)

#### 插入

在搜索的时候将父亲也给传进去，这样当查找不到(p == null)时可以让p指向父亲，方便插入

在搜索的时候传入父亲null，如果该树为空树，则p=null，需要让T直接指向新创建的节点

#### 删除

1.  右子树为空，直接让左子树的根接替该点
2.  左子树为空，直接让右子树的根接替该点
3.  若左右子树都不空，则让左子树的最右边那个点(该点的直接前驱)代替该点，并且删除左子树最右边的那个点，让那个点的左子树的根代替那个点，如果那个点就是该点左子树的根，则让该点的左孩子为那个点的左子树

### 平衡二叉树(AVL)

平衡因子$BF=Depth(T->lchild) - Depth(T->rchild)=-1,0,1$

类型|判定|操作
:--:|:--:|:--:
LL|插入左子树，左子树长高，根bf=1，左孩子bf=1|单次右旋
LR|插入左子树，左子树长高，根bf=1，左孩子bf=-1|左旋右旋
RR|插入右子树，右子树长高，根bf=-1，右孩子bf=-1|单次左旋
RL|插入右子树，右子树长高，根bf=-1，右孩子bf=1|右旋左旋

### B树

m阶树
1.  每个节点最多m棵子树
2.  根节点至少两棵子树
3.  除根外，所有非终端节点至少$\lceil\frac{m}{2}\rceil$棵子树
4.  非终端节点$(n, A_0, K_1, A_1, ..., K_n, A_n)$
5.  所有叶子节点都在同一层，不带信息

### B+树

m阶B+树
1.  n棵子树的节点含n个关键字
2.  所有叶子节点包含所有关键字信息

### 键树（数字查找树）

### 哈希

构造哈希函数
1.  直接定址法
2.  除留余数法

处理冲突
1.  $H_i = (H(key)+d_i) mod m$
2.  再哈希
3.  链地址：将所有冲突归到一个链表上