##  图

```c
FirstAdjVex(G, v)
NextAdjVex(G, v)
InsertVex(G, v)
DeleteVex(G, v)
InsertArc(G, v, w)
DeleteArc(G, v, w)
DFS(G, visit)
BFS(G, visit)
```

网，带权图

a--->b,a弧尾，b弧头

路径P(a,b)

回路P(a, a)

简单路径即图论中的圈

连通分量即图论中的连通片

一个有向图的生成森林由若干棵有向树组成

存储方式

邻接矩阵，适用于稠密图

```c
{
    adj;
    info;
}ArcCell, AdjMatrix[][];
{
    vexs;
    arcs;
    vexnum, arcnum;
    kind
}MGraph;
```

邻接表，适用于稀疏图

```c
{
    adjvex;
    nextarc;
    info;
}ArcNode;
{
    data;
    firstarc;
}VNode, AdjList[];
{
    vertices;
    vexnum, arcnum;
    kind;
}ALGraph;
```

逆邻接表，方便求入度以及以u为头的弧

十字链表

```c
{
    tailvex, headvex;
    tlink, hlink;
    info;
}ArcBox;
{
    data;
    firstin, firstout;
}VexNode;
{
    xlist[];
    vexnum, arcnum;
}OLGraph;
```

邻接多重表，无向图


```c
{
    mark;
    ivex, jvex;
    ilink, jlink;
    info;
}EBox;
{
    data;
    firstedge;
}VexBox;
{
    adjmulist[];
    vexnum, arcnum;
}AMLGraph;
```

### 图遍历

DFS用邻接矩阵遍历，查找每个顶点的邻接点所需的总时间是$O(n*n)$

DFS用邻接表遍历，查找邻接点所需时间为$O(e)$，查找顶点需要$O(n)$，总时间$O(n+e)$

### 连通性

#### 最小生成树

Prim

找$(U, \bar{U})$中代价最小的边，让边代价为0，并且将边的另一个端点加入U中，对这个点的邻边更新代价

时间复杂度$O(n^2)$，适合边稠密的图

Kruskal

初始条件是n个孤立顶点

选择两个顶点落在不同连通分量上的代价最小的边

时间复杂度$O(eloge)$，适合边稀疏

#### 关节点和重连通风量

连通度k，至少删去k个顶点才能破坏图的连通性

关节点：
1.  有两棵子树的根
2.  非叶子节点v点的子树中所有节点都没有指向v的祖先的边，v为关节点

$low(v) = min\{visited(v), visited(v->parent, v->parent->parent, ...), low(v->child, v->child->child, ...)\}$

如果$low(v->child) >= visited(v)$，v为割点，如果$count < G.vexnum$，根为割点

### DAG, AOV, AOE

DAG:有向无环图
